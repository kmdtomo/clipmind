# システムパターン: ClipMind

## アーキテクチャ概要

ClipMindはElectronフレームワークをベースとし、以下の主要コンポーネントで構成されます。

1.  **Mainプロセス:**
    *   アプリケーションのライフサイクル管理。
    *   ネイティブOS機能へのアクセス（グローバルショートカット、クリップボード監視など）。
    *   ウィンドウ（Rendererプロセス）の作成と管理。
    *   バックグラウンド処理（データ永続化、AI連携のオーケストレーション）。
    *   `electron-store`による初期データ管理。Phase 4以降はクラウドDBとの連携も担当。
2.  **Rendererプロセス:**
    *   React + ViteによるUIの描画とインタラクション。
    *   ユーザーインターフェース（履歴リスト、検索バー、設定画面など）を担当。
    *   Preloadスクリプト経由でMainプロセスと通信。
3.  **Preloadスクリプト:**
    *   MainプロセスとRendererプロセス間の安全なIPC（プロセス間通信）ブリッジ。
    *   Node.js APIやElectron APIの一部をRendererプロセスに公開。

## デザインパターンと原則

### クリーンアーキテクチャの採用

保守性、テスト容易性、拡張性を高めるため、**クリーンアーキテクチャ**の原則を適用します。これにより、ビジネスロジック（コア機能）とフレームワーク（Electron, React）、UI、外部サービス（AI API, DB）を明確に分離します。

*   **Entities (ドメイン層):** アプリケーションのコアとなるビジネスルールとデータ構造（例: `ClipboardItem`, `Snippet`）。フレームワークやUIに依存しない純粋なロジック。
*   **Use Cases (アプリケーション層):** アプリケーション固有のビジネスロジック。Entitiesを操作し、特定の機能（例: `SaveClipboardItemUseCase`, `SuggestCompletionUseCase`）を実現。
*   **Interface Adapters (インターフェースアダプター層):** Use Casesと外部要素（UI, DB, API）間のデータ変換を担当。Controllers, Presenters, Gatewaysが含まれる。
    *   **Controllers:** UIからの入力を受け取り、適切なUse Caseを呼び出す。
    *   **Presenters:** Use Caseからの出力をUIに適した形式に変換する。
    *   **Gateways:** データ永続化（`electron-store`や将来のクラウドDB）や外部API（Dify/OpenAI）とのインターフェース。
*   **Frameworks & Drivers (フレームワーク＆ドライバー層):** 最も外側の層。フレームワーク（Electron, React）、UIライブラリ、データベース、外部APIなど具体的な実装技術。

**適用方針:**

*   コアロジック（Entities, Use Cases）は、TypeScript/JavaScriptで記述し、特定のフレームワークへの依存を最小限に抑えます。
*   MainプロセスとRendererプロセス間で共有されるロジックは、共通のコアモジュールとして分離します。
*   IPCは、Interface Adapters層の一部として扱い、プロセス間の依存性を疎結合に保ちます。

### その他のパターン

*   **ローカルファースト:** Phase 1-3では`electron-store`によるローカルデータ管理を優先。Phase 4でクラウド同期を追加する際も、オフライン動作と高速なローカルアクセスを維持します。
*   **非同期処理:** クリップボード監視、API通信、ファイルI/Oなどは非同期に行い、UIの応答性を維持します。
*   **イベント駆動:** MainプロセスとRendererプロセス間の通信や、クリップボードの変更通知などはイベント駆動モデルを採用します。
*   **キャッシング:** API応答や頻繁にアクセスされるデータをキャッシュし、パフォーマンスとAPIコストを最適化します。
*   **プリフェッチ:** ユーザーの操作を予測し（例: フォーム要素へのマウスホバー）、関連データをバックグラウンドで事前に取得することで、体感的なレイテンシーを削減します。
*   **二段階表示:** ローカルで即時利用可能な候補（履歴、ローカル定型文）をまず表示し、その後APIから取得した高度な候補を追加表示することで、応答性を確保します。
*   **Dependency Injection:** コンポーネント間の依存関係を疎結合にし、テスト容易性を高めるために、DIコンテナの利用または手動での依存性注入を検討します。

## AI連携アーキテクチャ

*   AIモデル（GPT-4等、Dify経由または直接）との連携は、Gatewayパターンを通じてInterface Adapters層に実装します。
*   Use Cases層がAI Gatewayを呼び出し、コンテキスト情報（コピー内容、アクティブアプリ、フォーム情報など）を渡して候補生成やテキスト処理を依頼します。
*   プライバシー保護のため、機密情報のマスキング処理をGatewayまたはUse Case層で行います。

このアーキテクチャにより、将来的な技術スタックの変更や機能拡張に対して柔軟に対応できるシステムを目指します。
